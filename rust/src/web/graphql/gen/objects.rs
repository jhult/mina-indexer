// DO NOT EDIT THIS FILE
// This file was generated by https://github.com/tacogips/async-graphql-reverse
use super::{
    enums::{
        BlockSortByInput, FeetransferSortByInput, NextstakeSortByInput, SnarkSortByInput,
        StakeSortByInput, TransactionSortByInput,
    },
    input_objects::{
        BlockQueryInput, FeetransferQueryInput, NextstakeQueryInput, SnarkQueryInput,
        StakeQueryInput, TransactionQueryInput,
    },
    scalars::{DateTime, Long, ObjectId},
};
use crate::web::graphql::query_implementations::DataSource;
use async_graphql::*;
#[derive(Debug, Clone)]
pub struct BlockTransactionFeeTransfer {
    pub fee: Option<String>,
    pub recipient: Option<String>,
    pub r#type: Option<String>,
}
#[Object]
impl BlockTransactionFeeTransfer {
    pub async fn fee(&self) -> Option<String> {
        self.fee.clone()
    }
    pub async fn recipient(&self) -> Option<String> {
        self.recipient.clone()
    }
    pub async fn r#type(&self) -> Option<String> {
        self.r#type.clone()
    }
}
#[derive(Debug, Clone)]
pub struct TransactionFromAccount {
    pub token: Option<i64>,
}
#[Object]
impl TransactionFromAccount {
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolStateBlockchainState {
    pub date: Option<Long>,
    pub snarked_ledger_hash: Option<String>,
    pub staged_ledger_hash: Option<String>,
    pub utc_date: Option<Long>,
}
#[Object]
impl BlockProtocolStateBlockchainState {
    pub async fn date(&self) -> Option<Long> {
        self.date.clone()
    }
    pub async fn snarked_ledger_hash(&self) -> Option<String> {
        self.snarked_ledger_hash.clone()
    }
    pub async fn staged_ledger_hash(&self) -> Option<String> {
        self.staged_ledger_hash.clone()
    }
    pub async fn utc_date(&self) -> Option<Long> {
        self.utc_date.clone()
    }
}
#[derive(Debug, Clone)]
pub struct UpdateManyPayload {
    pub matched_count: i64,
    pub modified_count: i64,
}
#[Object]
impl UpdateManyPayload {
    pub async fn matched_count(&self) -> i64 {
        self.matched_count
    }
    pub async fn modified_count(&self) -> i64 {
        self.modified_count
    }
}
#[derive(Debug, Clone)]
pub struct StakeTiming {
    pub cliff_amount: Option<f64>,
    pub cliff_time: Option<i64>,
    pub initial_minimum_balance: Option<f64>,
    pub timed_epoch_end: Option<bool>,
    pub timed_in_epoch: Option<bool>,
    pub timed_weighting: Option<f64>,
    pub untimed_slot: Option<i64>,
    pub vesting_increment: Option<f64>,
    pub vesting_period: Option<i64>,
}
#[Object]
impl StakeTiming {
    pub async fn cliff_amount(&self) -> Option<f64> {
        self.cliff_amount
    }
    pub async fn cliff_time(&self) -> Option<i64> {
        self.cliff_time
    }
    pub async fn initial_minimum_balance(&self) -> Option<f64> {
        self.initial_minimum_balance
    }
    pub async fn timed_epoch_end(&self) -> Option<bool> {
        self.timed_epoch_end
    }
    pub async fn timed_in_epoch(&self) -> Option<bool> {
        self.timed_in_epoch
    }
    pub async fn timed_weighting(&self) -> Option<f64> {
        self.timed_weighting
    }
    pub async fn untimed_slot(&self) -> Option<i64> {
        self.untimed_slot
    }
    pub async fn vesting_increment(&self) -> Option<f64> {
        self.vesting_increment
    }
    pub async fn vesting_period(&self) -> Option<i64> {
        self.vesting_period
    }
}
#[derive(Debug, Clone)]
pub struct NextDelegationTotal {
    pub count_delegates: Option<i64>,
    pub total_delegated: Option<f64>,
}
#[Object]
impl NextDelegationTotal {
    pub async fn count_delegates(&self) -> Option<i64> {
        self.count_delegates
    }
    pub async fn total_delegated(&self) -> Option<f64> {
        self.total_delegated
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransaction {
    pub coinbase: Option<String>,
}
#[Object]
impl BlockTransaction {
    pub async fn coinbase(&self) -> Option<String> {
        self.coinbase.clone()
    }
    pub async fn coinbase_receiver_account(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockTransactionCoinbaseReceiverAccount>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_coinbase_receiver_account(ctx, self)
            .await
    }
    pub async fn fee_transfer(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<Vec<Option<BlockTransactionFeeTransfer>>>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_fee_transfer(ctx, self)
            .await
    }
    pub async fn user_commands(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<Vec<Option<BlockTransactionUserCommand>>>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_user_commands(ctx, self)
            .await
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionCoinbaseReceiverAccount {
    pub public_key: Option<String>,
}
#[Object]
impl BlockTransactionCoinbaseReceiverAccount {
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionUserCommand {
    pub amount: Option<f64>,
    pub block_height: Option<i64>,
    pub block_state_hash: Option<String>,
    pub date_time: Option<DateTime>,
    pub failure_reason: Option<String>,
    pub fee: Option<f64>,
    pub fee_token: Option<i64>,
    pub from: Option<String>,
    pub hash: Option<String>,
    pub id: Option<String>,
    pub is_delegation: Option<bool>,
    pub kind: Option<String>,
    pub memo: Option<String>,
    pub nonce: Option<i64>,
    pub to: Option<String>,
    pub token: Option<i64>,
}
#[Object]
impl BlockTransactionUserCommand {
    pub async fn amount(&self) -> Option<f64> {
        self.amount
    }
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn block_state_hash(&self) -> Option<String> {
        self.block_state_hash.clone()
    }
    pub async fn date_time(&self) -> Option<DateTime> {
        self.date_time.clone()
    }
    pub async fn failure_reason(&self) -> Option<String> {
        self.failure_reason.clone()
    }
    pub async fn fee(&self) -> Option<f64> {
        self.fee
    }
    pub async fn fee_payer(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockTransactionUserCommandFeePayer>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_user_command_fee_payer(ctx, self)
            .await
    }
    pub async fn fee_token(&self) -> Option<i64> {
        self.fee_token
    }
    pub async fn from(&self) -> Option<String> {
        self.from.clone()
    }
    pub async fn from_account(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockTransactionUserCommandFromAccount>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_user_command_from_account(ctx, self)
            .await
    }
    pub async fn hash(&self) -> Option<String> {
        self.hash.clone()
    }
    pub async fn id(&self) -> Option<String> {
        self.id.clone()
    }
    pub async fn is_delegation(&self) -> Option<bool> {
        self.is_delegation
    }
    pub async fn kind(&self) -> Option<String> {
        self.kind.clone()
    }
    pub async fn memo(&self) -> Option<String> {
        self.memo.clone()
    }
    pub async fn nonce(&self) -> Option<i64> {
        self.nonce
    }
    pub async fn receiver(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockTransactionUserCommandReceiver>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_user_command_receiver(ctx, self)
            .await
    }
    pub async fn source(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockTransactionUserCommandSource>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_user_command_source(ctx, self)
            .await
    }
    pub async fn to(&self) -> Option<String> {
        self.to.clone()
    }
    pub async fn to_account(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockTransactionUserCommandToAccount>> {
        ctx.data_unchecked::<DataSource>()
            .block_transaction_user_command_to_account(ctx, self)
            .await
    }
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct DelegationTotal {
    pub count_delegates: Option<i64>,
    pub total_delegated: Option<f64>,
}
#[Object]
impl DelegationTotal {
    pub async fn count_delegates(&self) -> Option<i64> {
        self.count_delegates
    }
    pub async fn total_delegated(&self) -> Option<f64> {
        self.total_delegated
    }
}
#[derive(Debug, Clone)]
pub struct BlockWinnerAccount {
    pub public_key: Option<String>,
}
#[Object]
impl BlockWinnerAccount {
    pub async fn balance(&self, ctx: &Context<'_>) -> Result<Option<BlockWinnerAccountBalance>> {
        ctx.data_unchecked::<DataSource>()
            .block_winner_account_balance(ctx, self)
            .await
    }
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct TransactionReceiver {
    pub public_key: Option<String>,
}
#[Object]
impl TransactionReceiver {
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct InsertManyPayload {
    pub inserted_ids: Vec<Option<ObjectId>>,
}
#[Object]
impl InsertManyPayload {
    pub async fn inserted_ids(&self) -> Vec<Option<ObjectId>> {
        self.inserted_ids.clone()
    }
}
#[derive(Debug, Clone)]
pub struct Stake {
    pub balance: Option<f64>,
    pub chain_id: Option<String>,
    pub delegate: Option<String>,
    pub epoch: Option<i64>,
    pub ledger_hash: Option<String>,
    pub nonce: Option<i64>,
    pub pk: Option<String>,
    pub public_key: Option<String>,
    pub receipt_chain_hash: Option<String>,
    pub token: Option<i64>,
    pub voting_for: Option<String>,
}
#[Object]
impl Stake {
    pub async fn balance(&self) -> Option<f64> {
        self.balance
    }
    pub async fn chain_id(&self) -> Option<String> {
        self.chain_id.clone()
    }
    pub async fn delegate(&self) -> Option<String> {
        self.delegate.clone()
    }
    pub async fn delegation_totals(&self, ctx: &Context<'_>) -> Result<Option<DelegationTotal>> {
        ctx.data_unchecked::<DataSource>()
            .stake_delegation_totals(ctx, self)
            .await
    }
    pub async fn epoch(&self) -> Option<i64> {
        self.epoch
    }
    pub async fn ledger_hash(&self) -> Option<String> {
        self.ledger_hash.clone()
    }
    pub async fn nonce(&self) -> Option<i64> {
        self.nonce
    }
    pub async fn permissions(&self, ctx: &Context<'_>) -> Result<Option<StakePermission>> {
        ctx.data_unchecked::<DataSource>()
            .stake_permissions(ctx, self)
            .await
    }
    pub async fn pk(&self) -> Option<String> {
        self.pk.clone()
    }
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
    pub async fn receipt_chain_hash(&self) -> Option<String> {
        self.receipt_chain_hash.clone()
    }
    pub async fn timing(&self, ctx: &Context<'_>) -> Result<Option<StakeTiming>> {
        ctx.data_unchecked::<DataSource>()
            .stake_timing(ctx, self)
            .await
    }
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
    pub async fn voting_for(&self) -> Option<String> {
        self.voting_for.clone()
    }
}
#[derive(Debug, Clone)]
pub struct TransactionFeePayer {
    pub token: Option<i64>,
}
#[Object]
impl TransactionFeePayer {
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct Nextstake {
    pub balance: Option<f64>,
    pub delegate: Option<String>,
    pub ledger_hash: Option<String>,
    pub nonce: Option<i64>,
    pub pk: Option<String>,
    pub public_key: Option<String>,
    pub receipt_chain_hash: Option<String>,
    pub token: Option<i64>,
    pub voting_for: Option<String>,
}
#[Object]
impl Nextstake {
    pub async fn balance(&self) -> Option<f64> {
        self.balance
    }
    pub async fn delegate(&self) -> Option<String> {
        self.delegate.clone()
    }
    pub async fn ledger_hash(&self) -> Option<String> {
        self.ledger_hash.clone()
    }
    pub async fn next_delegation_totals(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<NextDelegationTotal>> {
        ctx.data_unchecked::<DataSource>()
            .nextstake_next_delegation_totals(ctx, self)
            .await
    }
    pub async fn nonce(&self) -> Option<i64> {
        self.nonce
    }
    pub async fn permissions(&self, ctx: &Context<'_>) -> Result<Option<NextstakePermission>> {
        ctx.data_unchecked::<DataSource>()
            .nextstake_permissions(ctx, self)
            .await
    }
    pub async fn pk(&self) -> Option<String> {
        self.pk.clone()
    }
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
    pub async fn receipt_chain_hash(&self) -> Option<String> {
        self.receipt_chain_hash.clone()
    }
    pub async fn timing(&self, ctx: &Context<'_>) -> Result<Option<NextstakeTiming>> {
        ctx.data_unchecked::<DataSource>()
            .nextstake_timing(ctx, self)
            .await
    }
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
    pub async fn voting_for(&self) -> Option<String> {
        self.voting_for.clone()
    }
}
#[derive(Debug, Clone)]
pub struct Snark {
    pub block_height: Option<i64>,
    pub canonical: Option<bool>,
    pub date_time: Option<DateTime>,
    pub fee: Option<f64>,
    pub prover: Option<String>,
    pub work_ids: Option<Vec<Option<i64>>>,
}
#[Object]
impl Snark {
    pub async fn block(&self, ctx: &Context<'_>) -> Result<Option<Block>> {
        ctx.data_unchecked::<DataSource>()
            .snark_block(ctx, self)
            .await
    }
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn canonical(&self) -> Option<bool> {
        self.canonical
    }
    pub async fn date_time(&self) -> Option<DateTime> {
        self.date_time.clone()
    }
    pub async fn fee(&self) -> Option<f64> {
        self.fee
    }
    pub async fn prover(&self) -> Option<String> {
        self.prover.clone()
    }
    pub async fn work_ids(&self) -> Option<Vec<Option<i64>>> {
        self.work_ids.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionUserCommandToAccount {
    pub token: Option<i64>,
}
#[Object]
impl BlockTransactionUserCommandToAccount {
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct NextstakePermission {
    pub edit_state: Option<String>,
    pub send: Option<String>,
    pub set_delegate: Option<String>,
    pub set_permissions: Option<String>,
    pub set_verification_key: Option<String>,
    pub stake: Option<bool>,
}
#[Object]
impl NextstakePermission {
    pub async fn edit_state(&self) -> Option<String> {
        self.edit_state.clone()
    }
    pub async fn send(&self) -> Option<String> {
        self.send.clone()
    }
    pub async fn set_delegate(&self) -> Option<String> {
        self.set_delegate.clone()
    }
    pub async fn set_permissions(&self) -> Option<String> {
        self.set_permissions.clone()
    }
    pub async fn set_verification_key(&self) -> Option<String> {
        self.set_verification_key.clone()
    }
    pub async fn stake(&self) -> Option<bool> {
        self.stake
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionUserCommandSource {
    pub public_key: Option<String>,
}
#[Object]
impl BlockTransactionUserCommandSource {
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockCreatorAccount {
    pub public_key: Option<String>,
}
#[Object]
impl BlockCreatorAccount {
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolStateConsensusStateStakingEpochDatum {
    pub epoch_length: Option<i64>,
    pub lock_checkpoint: Option<String>,
    pub seed: Option<String>,
    pub start_checkpoint: Option<String>,
}
#[Object]
impl BlockProtocolStateConsensusStateStakingEpochDatum {
    pub async fn epoch_length(&self) -> Option<i64> {
        self.epoch_length
    }
    pub async fn ledger(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockProtocolStateConsensusStateStakingEpochDatumLedger>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state_consensus_state_staking_epoch_datum_ledger(ctx, self)
            .await
    }
    pub async fn lock_checkpoint(&self) -> Option<String> {
        self.lock_checkpoint.clone()
    }
    pub async fn seed(&self) -> Option<String> {
        self.seed.clone()
    }
    pub async fn start_checkpoint(&self) -> Option<String> {
        self.start_checkpoint.clone()
    }
}
#[derive(Debug, Clone)]
pub struct Query {}
#[Object]
impl Query {
    pub async fn block(&self, ctx: &Context<'_>, query: BlockQueryInput) -> Result<Option<Block>> {
        ctx.data_unchecked::<DataSource>()
            .query_block(ctx, self, query)
            .await
    }
    pub async fn blocks(
        &self,
        ctx: &Context<'_>,
        limit: Option<i64>,
        sort_by: BlockSortByInput,
        query: BlockQueryInput,
    ) -> Result<Vec<Option<Block>>> {
        ctx.data_unchecked::<DataSource>()
            .query_blocks(ctx, self, limit, sort_by, query)
            .await
    }
    pub async fn feetransfer(
        &self,
        ctx: &Context<'_>,
        query: FeetransferQueryInput,
    ) -> Result<Option<Feetransfer>> {
        ctx.data_unchecked::<DataSource>()
            .query_feetransfer(ctx, self, query)
            .await
    }
    pub async fn feetransfers(
        &self,
        ctx: &Context<'_>,
        query: FeetransferQueryInput,
        limit: Option<i64>,
        sort_by: FeetransferSortByInput,
    ) -> Result<Vec<Option<Feetransfer>>> {
        ctx.data_unchecked::<DataSource>()
            .query_feetransfers(ctx, self, query, limit, sort_by)
            .await
    }
    pub async fn nextstake(
        &self,
        ctx: &Context<'_>,
        query: NextstakeQueryInput,
    ) -> Result<Option<Nextstake>> {
        ctx.data_unchecked::<DataSource>()
            .query_nextstake(ctx, self, query)
            .await
    }
    pub async fn nextstakes(
        &self,
        ctx: &Context<'_>,
        sort_by: NextstakeSortByInput,
        query: NextstakeQueryInput,
        limit: Option<i64>,
    ) -> Result<Vec<Option<Nextstake>>> {
        ctx.data_unchecked::<DataSource>()
            .query_nextstakes(ctx, self, sort_by, query, limit)
            .await
    }
    pub async fn snark(&self, ctx: &Context<'_>, query: SnarkQueryInput) -> Result<Option<Snark>> {
        ctx.data_unchecked::<DataSource>()
            .query_snark(ctx, self, query)
            .await
    }
    pub async fn snarks(
        &self,
        ctx: &Context<'_>,
        query: SnarkQueryInput,
        limit: Option<i64>,
        sort_by: SnarkSortByInput,
    ) -> Result<Vec<Option<Snark>>> {
        ctx.data_unchecked::<DataSource>()
            .query_snarks(ctx, self, query, limit, sort_by)
            .await
    }
    pub async fn stake(&self, ctx: &Context<'_>, query: StakeQueryInput) -> Result<Option<Stake>> {
        ctx.data_unchecked::<DataSource>()
            .query_stake(ctx, self, query)
            .await
    }
    pub async fn stakes(
        &self,
        ctx: &Context<'_>,
        query: StakeQueryInput,
        limit: Option<i64>,
        sort_by: StakeSortByInput,
    ) -> Result<Vec<Option<Stake>>> {
        ctx.data_unchecked::<DataSource>()
            .query_stakes(ctx, self, query, limit, sort_by)
            .await
    }
    pub async fn transaction(
        &self,
        ctx: &Context<'_>,
        query: TransactionQueryInput,
    ) -> Result<Option<Transaction>> {
        ctx.data_unchecked::<DataSource>()
            .query_transaction(ctx, self, query)
            .await
    }
    pub async fn transactions(
        &self,
        ctx: &Context<'_>,
        query: TransactionQueryInput,
        limit: Option<i64>,
        sort_by: TransactionSortByInput,
    ) -> Result<Vec<Option<Transaction>>> {
        ctx.data_unchecked::<DataSource>()
            .query_transactions(ctx, self, query, limit, sort_by)
            .await
    }
}
#[derive(Debug, Clone)]
pub struct BlockSnarkJob {
    pub block_height: Option<i64>,
    pub block_state_hash: Option<String>,
    pub date_time: Option<DateTime>,
    pub fee: Option<i64>,
    pub prover: Option<String>,
    pub work_ids: Option<Vec<Option<i64>>>,
}
#[Object]
impl BlockSnarkJob {
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn block_state_hash(&self) -> Option<String> {
        self.block_state_hash.clone()
    }
    pub async fn date_time(&self) -> Option<DateTime> {
        self.date_time.clone()
    }
    pub async fn fee(&self) -> Option<i64> {
        self.fee
    }
    pub async fn prover(&self) -> Option<String> {
        self.prover.clone()
    }
    pub async fn work_ids(&self) -> Option<Vec<Option<i64>>> {
        self.work_ids.clone()
    }
}
#[derive(Debug, Clone)]
pub struct Feetransfer {
    pub block_height: Option<i64>,
    pub canonical: Option<bool>,
    pub date_time: Option<DateTime>,
    pub fee: Option<i64>,
    pub recipient: Option<String>,
    pub r#type: Option<String>,
}
#[Object]
impl Feetransfer {
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn block_state_hash(&self, ctx: &Context<'_>) -> Result<Option<Block>> {
        ctx.data_unchecked::<DataSource>()
            .feetransfer_block_state_hash(ctx, self)
            .await
    }
    pub async fn canonical(&self) -> Option<bool> {
        self.canonical
    }
    pub async fn date_time(&self) -> Option<DateTime> {
        self.date_time.clone()
    }
    pub async fn fee(&self) -> Option<i64> {
        self.fee
    }
    pub async fn recipient(&self) -> Option<String> {
        self.recipient.clone()
    }
    pub async fn r#type(&self) -> Option<String> {
        self.r#type.clone()
    }
}
#[derive(Debug, Clone)]
pub struct StakePermission {
    pub edit_state: Option<String>,
    pub send: Option<String>,
    pub set_delegate: Option<String>,
    pub set_permissions: Option<String>,
    pub set_verification_key: Option<String>,
    pub stake: Option<bool>,
}
#[Object]
impl StakePermission {
    pub async fn edit_state(&self) -> Option<String> {
        self.edit_state.clone()
    }
    pub async fn send(&self) -> Option<String> {
        self.send.clone()
    }
    pub async fn set_delegate(&self) -> Option<String> {
        self.set_delegate.clone()
    }
    pub async fn set_permissions(&self) -> Option<String> {
        self.set_permissions.clone()
    }
    pub async fn set_verification_key(&self) -> Option<String> {
        self.set_verification_key.clone()
    }
    pub async fn stake(&self) -> Option<bool> {
        self.stake
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionUserCommandFromAccount {
    pub token: Option<i64>,
}
#[Object]
impl BlockTransactionUserCommandFromAccount {
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct Transaction {
    pub amount: Option<f64>,
    pub block_height: Option<i64>,
    pub canonical: Option<bool>,
    pub date_time: Option<DateTime>,
    pub failure_reason: Option<String>,
    pub fee: Option<f64>,
    pub fee_token: Option<i64>,
    pub from: Option<String>,
    pub hash: Option<String>,
    pub id: Option<String>,
    pub is_delegation: Option<bool>,
    pub kind: Option<String>,
    pub memo: Option<String>,
    pub nonce: Option<i64>,
    pub to: Option<String>,
    pub token: Option<i64>,
}
#[Object]
impl Transaction {
    pub async fn amount(&self) -> Option<f64> {
        self.amount
    }
    pub async fn block(&self, ctx: &Context<'_>) -> Result<Option<Block>> {
        ctx.data_unchecked::<DataSource>()
            .transaction_block(ctx, self)
            .await
    }
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn canonical(&self) -> Option<bool> {
        self.canonical
    }
    pub async fn date_time(&self) -> Option<DateTime> {
        self.date_time.clone()
    }
    pub async fn failure_reason(&self) -> Option<String> {
        self.failure_reason.clone()
    }
    pub async fn fee(&self) -> Option<f64> {
        self.fee
    }
    pub async fn fee_payer(&self, ctx: &Context<'_>) -> Result<Option<TransactionFeePayer>> {
        ctx.data_unchecked::<DataSource>()
            .transaction_fee_payer(ctx, self)
            .await
    }
    pub async fn fee_token(&self) -> Option<i64> {
        self.fee_token
    }
    pub async fn from(&self) -> Option<String> {
        self.from.clone()
    }
    pub async fn from_account(&self, ctx: &Context<'_>) -> Result<Option<TransactionFromAccount>> {
        ctx.data_unchecked::<DataSource>()
            .transaction_from_account(ctx, self)
            .await
    }
    pub async fn hash(&self) -> Option<String> {
        self.hash.clone()
    }
    pub async fn id(&self) -> Option<String> {
        self.id.clone()
    }
    pub async fn is_delegation(&self) -> Option<bool> {
        self.is_delegation
    }
    pub async fn kind(&self) -> Option<String> {
        self.kind.clone()
    }
    pub async fn memo(&self) -> Option<String> {
        self.memo.clone()
    }
    pub async fn nonce(&self) -> Option<i64> {
        self.nonce
    }
    pub async fn receiver(&self, ctx: &Context<'_>) -> Result<Option<TransactionReceiver>> {
        ctx.data_unchecked::<DataSource>()
            .transaction_receiver(ctx, self)
            .await
    }
    pub async fn source(&self, ctx: &Context<'_>) -> Result<Option<TransactionSource>> {
        ctx.data_unchecked::<DataSource>()
            .transaction_source(ctx, self)
            .await
    }
    pub async fn to(&self) -> Option<String> {
        self.to.clone()
    }
    pub async fn to_account(&self, ctx: &Context<'_>) -> Result<Option<TransactionToAccount>> {
        ctx.data_unchecked::<DataSource>()
            .transaction_to_account(ctx, self)
            .await
    }
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionUserCommandFeePayer {
    pub token: Option<i64>,
}
#[Object]
impl BlockTransactionUserCommandFeePayer {
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct BlockWinnerAccountBalance {
    pub block_height: Option<i64>,
    pub liquid: Option<i64>,
    pub locked: Option<Long>,
    pub state_hash: Option<String>,
    pub total: Option<String>,
    pub unknown: Option<Long>,
}
#[Object]
impl BlockWinnerAccountBalance {
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn liquid(&self) -> Option<i64> {
        self.liquid
    }
    pub async fn locked(&self) -> Option<Long> {
        self.locked.clone()
    }
    pub async fn state_hash(&self) -> Option<String> {
        self.state_hash.clone()
    }
    pub async fn total(&self) -> Option<String> {
        self.total.clone()
    }
    pub async fn unknown(&self) -> Option<Long> {
        self.unknown.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolState {
    pub previous_state_hash: Option<String>,
}
#[Object]
impl BlockProtocolState {
    pub async fn blockchain_state(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockProtocolStateBlockchainState>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state_blockchain_state(ctx, self)
            .await
    }
    pub async fn consensus_state(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockProtocolStateConsensusState>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state_consensus_state(ctx, self)
            .await
    }
    pub async fn previous_state_hash(&self) -> Option<String> {
        self.previous_state_hash.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolStateConsensusStateNextEpochDatum {
    pub epoch_length: Option<i64>,
    pub lock_checkpoint: Option<String>,
    pub seed: Option<String>,
    pub start_checkpoint: Option<String>,
}
#[Object]
impl BlockProtocolStateConsensusStateNextEpochDatum {
    pub async fn epoch_length(&self) -> Option<i64> {
        self.epoch_length
    }
    pub async fn ledger(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockProtocolStateConsensusStateNextEpochDatumLedger>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state_consensus_state_next_epoch_datum_ledger(ctx, self)
            .await
    }
    pub async fn lock_checkpoint(&self) -> Option<String> {
        self.lock_checkpoint.clone()
    }
    pub async fn seed(&self) -> Option<String> {
        self.seed.clone()
    }
    pub async fn start_checkpoint(&self) -> Option<String> {
        self.start_checkpoint.clone()
    }
}
#[derive(Debug, Clone)]
pub struct DeleteManyPayload {
    pub deleted_count: i64,
}
#[Object]
impl DeleteManyPayload {
    pub async fn deleted_count(&self) -> i64 {
        self.deleted_count
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolStateConsensusState {
    pub block_height: Option<i64>,
    pub blockchain_length: Option<i64>,
    pub epoch: Option<i64>,
    pub epoch_count: Option<i64>,
    pub has_ancestor_in_same_checkpoint_window: Option<bool>,
    pub last_vrf_output: Option<String>,
    pub min_window_density: Option<i64>,
    pub slot: Option<i64>,
    pub slot_since_genesis: Option<i64>,
    pub total_currency: Option<f64>,
}
#[Object]
impl BlockProtocolStateConsensusState {
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn blockchain_length(&self) -> Option<i64> {
        self.blockchain_length
    }
    pub async fn epoch(&self) -> Option<i64> {
        self.epoch
    }
    pub async fn epoch_count(&self) -> Option<i64> {
        self.epoch_count
    }
    pub async fn has_ancestor_in_same_checkpoint_window(&self) -> Option<bool> {
        self.has_ancestor_in_same_checkpoint_window
    }
    pub async fn last_vrf_output(&self) -> Option<String> {
        self.last_vrf_output.clone()
    }
    pub async fn min_window_density(&self) -> Option<i64> {
        self.min_window_density
    }
    pub async fn next_epoch_data(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockProtocolStateConsensusStateNextEpochDatum>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state_consensus_state_next_epoch_data(ctx, self)
            .await
    }
    pub async fn slot(&self) -> Option<i64> {
        self.slot
    }
    pub async fn slot_since_genesis(&self) -> Option<i64> {
        self.slot_since_genesis
    }
    pub async fn staking_epoch_data(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<BlockProtocolStateConsensusStateStakingEpochDatum>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state_consensus_state_staking_epoch_data(ctx, self)
            .await
    }
    pub async fn total_currency(&self) -> Option<f64> {
        self.total_currency
    }
}
#[derive(Debug, Clone)]
pub struct TransactionSource {
    pub public_key: Option<String>,
}
#[Object]
impl TransactionSource {
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct TransactionToAccount {
    pub token: Option<i64>,
}
#[Object]
impl TransactionToAccount {
    pub async fn token(&self) -> Option<i64> {
        self.token
    }
}
#[derive(Debug, Clone)]
pub struct NextstakeTiming {
    pub cliff_amount: Option<f64>,
    pub cliff_time: Option<i64>,
    pub initial_minimum_balance: Option<f64>,
    pub vesting_increment: Option<f64>,
    pub vesting_period: Option<i64>,
}
#[Object]
impl NextstakeTiming {
    pub async fn cliff_amount(&self) -> Option<f64> {
        self.cliff_amount
    }
    pub async fn cliff_time(&self) -> Option<i64> {
        self.cliff_time
    }
    pub async fn initial_minimum_balance(&self) -> Option<f64> {
        self.initial_minimum_balance
    }
    pub async fn vesting_increment(&self) -> Option<f64> {
        self.vesting_increment
    }
    pub async fn vesting_period(&self) -> Option<i64> {
        self.vesting_period
    }
}
#[derive(Debug, Clone)]
pub struct Block {
    pub block_height: Option<i64>,
    pub canonical: Option<bool>,
    pub creator: Option<String>,
    pub date_time: Option<DateTime>,
    pub received_time: Option<DateTime>,
    pub snark_fees: Option<String>,
    pub state_hash: Option<String>,
    pub state_hash_field: Option<String>,
    pub tx_fees: Option<String>,
}
#[Object]
impl Block {
    pub async fn block_height(&self) -> Option<i64> {
        self.block_height
    }
    pub async fn canonical(&self) -> Option<bool> {
        self.canonical
    }
    pub async fn creator(&self) -> Option<String> {
        self.creator.clone()
    }
    pub async fn creator_account(&self, ctx: &Context<'_>) -> Result<Option<BlockCreatorAccount>> {
        ctx.data_unchecked::<DataSource>()
            .block_creator_account(ctx, self)
            .await
    }
    pub async fn date_time(&self) -> Option<DateTime> {
        self.date_time.clone()
    }
    pub async fn protocol_state(&self, ctx: &Context<'_>) -> Result<Option<BlockProtocolState>> {
        ctx.data_unchecked::<DataSource>()
            .block_protocol_state(ctx, self)
            .await
    }
    pub async fn received_time(&self) -> Option<DateTime> {
        self.received_time.clone()
    }
    pub async fn snark_fees(&self) -> Option<String> {
        self.snark_fees.clone()
    }
    pub async fn snark_jobs(
        &self,
        ctx: &Context<'_>,
    ) -> Result<Option<Vec<Option<BlockSnarkJob>>>> {
        ctx.data_unchecked::<DataSource>()
            .block_snark_jobs(ctx, self)
            .await
    }
    pub async fn state_hash(&self) -> Option<String> {
        self.state_hash.clone()
    }
    pub async fn state_hash_field(&self) -> Option<String> {
        self.state_hash_field.clone()
    }
    pub async fn transactions(&self, ctx: &Context<'_>) -> Result<Option<BlockTransaction>> {
        ctx.data_unchecked::<DataSource>()
            .block_transactions(ctx, self)
            .await
    }
    pub async fn tx_fees(&self) -> Option<String> {
        self.tx_fees.clone()
    }
    pub async fn winner_account(&self, ctx: &Context<'_>) -> Result<Option<BlockWinnerAccount>> {
        ctx.data_unchecked::<DataSource>()
            .block_winner_account(ctx, self)
            .await
    }
}
#[derive(Debug, Clone)]
pub struct BlockTransactionUserCommandReceiver {
    pub public_key: Option<String>,
}
#[Object]
impl BlockTransactionUserCommandReceiver {
    pub async fn public_key(&self) -> Option<String> {
        self.public_key.clone()
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolStateConsensusStateNextEpochDatumLedger {
    pub hash: Option<String>,
    pub total_currency: Option<f64>,
}
#[Object]
impl BlockProtocolStateConsensusStateNextEpochDatumLedger {
    pub async fn hash(&self) -> Option<String> {
        self.hash.clone()
    }
    pub async fn total_currency(&self) -> Option<f64> {
        self.total_currency
    }
}
#[derive(Debug, Clone)]
pub struct BlockProtocolStateConsensusStateStakingEpochDatumLedger {
    pub hash: Option<String>,
    pub total_currency: Option<f64>,
}
#[Object]
impl BlockProtocolStateConsensusStateStakingEpochDatumLedger {
    pub async fn hash(&self) -> Option<String> {
        self.hash.clone()
    }
    pub async fn total_currency(&self) -> Option<f64> {
        self.total_currency
    }
}
